/*
http://acmp.ru/index.asp?main=task&id_task=535
Володя написал программу, которая складывает в столбик два числа. К сожалению, он не разобрался, как правильно переносить единицу из одного разряда в следующий. Поэтому программа стала выполняться следующим образом. Сначала она складывает последние цифры обоих чисел и записывает результат, как в случае, если он однозначный, так и в случае, если он двузначный. Затем программа складывает предпоследние цифры обоих чисел и результат сложения приписывает слева к результату предыдущего сложения. Далее процесс повторяется для всех разрядов. Если в одном числе цифр меньше, чем в другом, то программа размещает нули в соответствующих разрядах более короткого числа.

Федя хочет доказать Володе, что его способ сложения не обладает свойством ассоциативности. В частности, Федя утверждает, что существуют три числа, для которых важен порядок, в котором их складывают (при этом разрешается складывать числа в любом порядке, например можно сначала сложить первое число и последнее, а затем прибавить к ним среднее). Федя привел даже пример трех таких чисел.

Требуется написать программу, которая поможет Феде и Володе определить, верно ли утверждение, что, складывая заданные три числа в разном порядке, можно получить разные суммы.

Входные данные
Входной файл INPUT.TXT содержит в одной строке три целых числа a, b и c (1 ≤ a, b, c ≤ 106). Все числа в строке разделены пробелом.

Выходные данные
В первую строку выходного файла OUTPUT.TXT необходимо вывести слово YES, если данные три числа можно сложить разными способами и получить разные суммы. В противном случае, необходимо вывести слово NO.
В последующих строках необходимо вывести все возможные суммы, которые можно получить, складывая числа a, b и c. Суммы следует выводить по одной на строке и в порядке их возрастания.
*/
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <string.h>
using namespace std;
int compare_long(int* a, int* b) //a<b==-1, a>b==1
{
    if (a[0]<b[0]) return -1;
    else if (a[0]>b[0]) return 1;
    else
    {
        int i;
        for (i=a[0]; i>=1; i--)
        {
            if (a[i]<b[i]) return -1;
            else if (a[i]>b[i]) return 1;
        }
        return 0;
    }
}
 
int* error_add_long(int* a, int* b)
{
   int* ans = (int*)malloc((a[0]+b[0]+1)*sizeof(int));
   int i,t;
   int* min;
   int* max;
   a[0]<b[0] ? (min=a, max=b) : (min=b, max=a);
   ans[0]=0;
   for (i=1; i<=min[0]; i++)
   {
      t=a[i]+b[i];
      if (t>9)
      {
         ans[0]+=2;
         ans[ans[0]-1]=t%10;
         ans[ans[0]]=t/10;
      }
      else
      {
         ans[0]++;
         ans[ans[0]]=t;
      }
   }
   for (i=min[0]+1; i<=max[0]; i++)
   {
      ans[0]++;
      ans[ans[0]]=max[i];
   }
   return ans;
}
 
int main()
{
   ifstream fin("input.txt");
   ofstream fout("output.txt");
   int i, j;
   int a[20], b[20], c[20];
   char ss[10];
 
      fin>>ss;
      a[0]=strlen(ss);
      for (j=0; j<a[0]; j++)
         a[a[0]-j]=(int)ss[j]-48;
 
      fin>>ss;
      b[0]=strlen(ss);
      for (j=0; j<b[0]; j++)
         b[b[0]-j]=(int)ss[j]-48;
 
      fin>>ss;
      c[0]=strlen(ss);
      for (j=0; j<c[0]; j++)
         c[c[0]-j]=(int)ss[j]-48;
 
   int* s1;
   int* s2;
   int* s3;
 
   s1=error_add_long(error_add_long(a, b), c);
   s2=error_add_long(error_add_long(a, c), b);
   s3=error_add_long(error_add_long(b, c), a);
 
   int* ans[3]={s1,s2,s3};
 
 
   int x12,x23,x13;
   x12=compare_long(s1,s2);
   x13=compare_long(s1,s3);
   x23=compare_long(s2,s3);
 
   int x[3];
 
   if (x12==0 && x13==0 && x23==0)
   {
      fout<<"NO"<<'\n';
      for (j=s1[0]; j>=1; j--) fout<<s1[j];
      fout<<'\n';
   }
   else
   {
      fout<<"YES"<<'\n';
      if (x12<=0 && x13<=0) //+++
    {
      x[0]=1;
      if (x23<0)
      { x[1]=2; x[2]=3; }
      if (x23>0)
      { x[1]=3; x[2]=2; }
      if (x23==0) { x[1]=2; x[2]=0; }
   }
   else if (x12>=0 && x23<=0)
   {
      x[0]=2;
      if (x13<0)
      { x[1]=1; x[2]=3; }
      if (x13>0)
      { x[1]=3; x[2]=1; }
      if (x13==0) { x[1]=1; x[2]=0; }
   }
   else if (x13>=0 && x23>=0)
   {
      x[0]=3;
      if (x12<0)
      { x[1]=1; x[2]=2; }
      if (x12>0)
      { x[1]=2; x[2]=1; }
      if (x12==0) { x[1]=2; x[2]=0; }
    }
   int k;
      for (k=0; k<3; k++)
      {
         if (x[k]!=0){
            for (j=ans[x[k]-1][0]; j>=1; j--) fout<<ans[x[k]-1][j];
            fout<<'\n';
         }
      }
   }
   fin.close();
   fout.close();
   return 0;
}